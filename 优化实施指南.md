# 视频应用项目 - 优化实施指南

## 快速开始（第一周）

### 任务1：修复N+1查询（2小时）

**文件：** `backend/app/api/community.py`

**步骤1：修复 get_comments()**
```python
# 替换现有的 get_comments 函数
@router.get("/posts/{post_id}/comments")
async def get_comments(
    post_id: int,
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=50),
    parent_id: Optional[int] = None,
    current_user: Optional[User] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db)
):
    """获取评论列表 - 优化版本"""
    query = select(PostComment).where(
        PostComment.post_id == post_id,
        PostComment.status == "visible"
    )
    
    if parent_id:
        query = query.where(PostComment.parent_id == parent_id)
    else:
        query = query.where(PostComment.parent_id == None)
    
    query = query.order_by(desc(PostComment.is_top), desc(PostComment.created_at))
    query = query.offset((page - 1) * page_size).limit(page_size)
    
    result = await db.execute(query)
    comments = result.scalars().all()
    
    if not comments:
        return []
    
    # ========== 批量查询优化 ==========
    comment_ids = [c.id for c in comments]
    user_ids = list(set(c.user_id for c in comments))
    
    # 1. 批量获取用户信息
    users_result = await db.execute(select(User).where(User.id.in_(user_ids)))
    users_map = {u.id: u for u in users_result.scalars().all()}
    
    # 2. 批量获取VIP信息
    vip_result = await db.execute(
        select(UserVIP).where(UserVIP.user_id.in_(user_ids), UserVIP.is_active == True)
    )
    vip_map = {v.user_id: v for v in vip_result.scalars().all()}
    
    # 3. 批量获取点赞状态
    liked_comment_ids = set()
    if current_user:
        like_result = await db.execute(
            select(PostCommentLike.comment_id).where(
                PostCommentLike.comment_id.in_(comment_ids),
                PostCommentLike.user_id == current_user.id
            )
        )
        liked_comment_ids = set(r[0] for r in like_result.fetchall())
    
    # ========== 构建响应 ==========
    response = []
    for comment in comments:
        comment_user = users_map.get(comment.user_id)
        if not comment_user:
            continue
        
        vip = vip_map.get(comment.user_id)
        is_vip = vip is not None and vip.expire_date and vip.expire_date > datetime.utcnow()
        vip_level = vip.vip_level if (is_vip and vip) else 0
        
        user_brief = {
            "id": comment_user.id,
            "username": comment_user.username,
            "nickname": comment_user.nickname,
            "avatar": comment_user.avatar,
            "is_vip": is_vip,
            "vip_level": vip_level
        }
        
        reply_to_user = None
        if comment.reply_to_user_id and comment.reply_to_user_id in users_map:
            reply_user = users_map[comment.reply_to_user_id]
            reply_to_user = {
                "id": reply_user.id,
                "username": reply_user.username,
                "nickname": reply_user.nickname
            }
        
        response.append({
            "id": comment.id,
            "user": user_brief,
            "content": comment.content,
            "images": comment.images or [],
            "parent_id": comment.parent_id,
            "reply_to_user": reply_to_user,
            "like_count": comment.like_count,
            "reply_count": comment.reply_count,
            "created_at": comment.created_at,
            "is_liked": comment.id in liked_comment_ids
        })
    
    return response
```

**步骤2：修复 get_followers() 和 get_following()**
```python
# 类似的批量查询优化应用于这两个函数
# 关键是：先获取所有ID，然后批量查询，最后构建响应
```

---

### 任务2：实现缓存层（1.5小时）

**文件：** `backend/app/api/videos.py`

**步骤1：添加缓存到视频列表**
```python
@router.get("")
async def list_videos(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    category_id: Optional[int] = None,
    search: Optional[str] = None,
    sort_by: Optional[str] = None,
    current_user: Optional[User] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db)
):
    """获取视频列表 - 带缓存"""
    from app.services.cache_service import CacheService, CacheTTL
    
    # 构建缓存键（不包含 current_user，因为点赞状态是个人的）
    cache_key = f"videos:list:{category_id}:{page}:{page_size}:{sort_by}:{search}"
    
    # 尝试从缓存获取
    cached_data = await CacheService.get(cache_key)
    if cached_data:
        # 如果有当前用户，需要补充个人状态（点赞等）
        if current_user:
            # 获取用户点赞的视频ID
            from app.models.social import VideoLike
            like_result = await db.execute(
                select(VideoLike.video_id).where(VideoLike.user_id == current_user.id)
            )
            liked_ids = set(r[0] for r in like_result.fetchall())
            
            # 更新缓存数据中的点赞状态
            for item in cached_data.get("items", []):
                item["is_liked"] = item["id"] in liked_ids
        
        return cached_data
    
    # 原有的查询逻辑...
    # ... (保持现有代码)
    
    # 构建响应
    response = VideoListResponse(
        items=items,
        total=total,
        page=page,
        page_size=page_size
    )
    
    # 存入缓存（不包含个人状态）
    cache_data = {
        "items": [item.dict() for item in items],
        "total": total,
        "page": page,
        "page_size": page_size
    }
    await CacheService.set(cache_key, cache_data, CacheTTL.SHORT)
    
    return response
```

**步骤2：添加缓存到分类列表**
```python
@router.get("/categories")
async def list_categories(db: AsyncSession = Depends(get_db)):
    """获取视频分类列表 - 带缓存"""
    from app.services.cache_service import CacheService, CacheTTL
    
    # 尝试从缓存获取
    cached = await CacheService.get("categories:all")
    if cached:
        return cached
    
    # 原有的查询逻辑...
    # ... (保持现有代码)
    
    # 存入缓存
    await CacheService.set("categories:all", root_items, CacheTTL.LONG)
    
    return root_items
```

---

### 任务3：添加数据库索引（30分钟）

**文件：** `backend/app/models/community.py`

```python
# 修改 Post 类
class Post(Base):
    __tablename__ = "posts"
    
    # ... 现有字段 ...
    
    __table_args__ = (
        # 现有索引
        Index('idx_post_user_created', 'user_id', 'created_at'),
        Index('idx_post_status_created', 'status', 'created_at'),
        
        # 新增索引
        Index('idx_post_visibility_created', 'visibility', 'created_at'),
        Index('idx_post_is_hot_created', 'is_hot', 'created_at'),
        Index('idx_post_like_count', 'like_count', 'created_at'),
        Index('idx_post_view_count', 'view_count', 'created_at'),
    )

# 修改 PostComment 类
class PostComment(Base):
    __tablename__ = "post_comments"
    
    # ... 现有字段 ...
    
    __table_args__ = (
        Index('idx_post_comment_post_created', 'post_id', 'created_at'),
        Index('idx_post_comment_user_created', 'user_id', 'created_at'),
        Index('idx_post_comment_parent_id', 'parent_id'),
    )
```

**执行迁移：**
```bash
# 使用 Alembic 创建迁移
alembic revision --autogenerate -m "Add missing indexes"

# 应用迁移
alembic upgrade head
```

---

### 任务4：安全加固（1小时）

**步骤1：修复 XSS 漏洞**

**文件：** `frontend/src/views/user/CommunityDetail.vue`

```vue
<script setup>
import DOMPurify from 'dompurify'

// 添加 DOMPurify 处理
const sanitizedContent = computed(() => {
  if (!post.value?.content) return ''
  return DOMPurify.sanitize(post.value.content, {
    ALLOWED_TAGS: [],  // 不允许任何 HTML 标签
    ALLOWED_ATTR: []
  })
})
</script>

<template>
  <!-- 使用 sanitizedContent 而不是直接使用 post.content -->
  <p class="content-text">{{ sanitizedContent }}</p>
</template>
```

**步骤2：添加输入验证**

**文件：** `backend/app/api/community.py`

```python
from bleach import clean
from pydantic import validator

class PostCreate(BaseModel):
    content: str
    images: List[str] = []
    
    @validator('content')
    def validate_content(cls, v):
        if not v or len(v.strip()) == 0:
            raise ValueError('内容不能为空')
        if len(v) > 10000:
            raise ValueError('内容过长（最多10000字）')
        # 清理 HTML 标签
        return clean(v, tags=[], strip=True)
    
    @validator('images')
    def validate_images(cls, v):
        if len(v) > 9:
            raise ValueError('最多上传9张图片')
        return v
```

**步骤3：添加速率限制**

**文件：** `backend/app/api/auth.py`

```python
from app.core.rate_limit import rate_limit

@router.post("/login")
@rate_limit("5/minute")  # 每分钟最多5次登录尝试
async def login(credentials: LoginRequest, ...):
    # 登录逻辑
    pass

@router.post("/register")
@rate_limit("3/minute")  # 每分钟最多3次注册
async def register(user_in: UserCreate, ...):
    # 注册逻辑
    pass
```

---

## 第二周：前端优化

### 任务5：组件拆分（4小时）

**创建新文件结构：**

```
frontend/src/views/user/
├── CommunityDetail.vue (主容器)
├── components/
│   ├── PostHeader.vue (帖子头部)
│   ├── PostContent.vue (帖子内容)
│   ├── CommentsList.vue (评论列表)
│   ├── CommentItem.vue (单条评论)
│   ├── CommentInput.vue (评论输入)
│   └── ImagePreview.vue (图片预览)
```

**PostHeader.vue：**
```vue
<template>
  <div class="user-row">
    <img :src="getAvatarUrl(post.user?.avatar)" class="avatar" />
    <div class="user-meta">
      <span class="username">{{ post.user?.nickname }}</span>
      <span class="date">{{ formatDate(post.created_at) }}</span>
    </div>
    <button v-if="!post.is_followed" class="follow-btn" @click="$emit('follow')">
      +关注
    </button>
  </div>
</template>

<script setup>
defineProps({
  post: Object
})

defineEmits(['follow'])
</script>
```

**CommentsList.vue：**
```vue
<template>
  <div class="comments-section">
    <div class="comments-header">
      <span>{{ post?.comment_count || 0 }}条评论</span>
      <div class="sort-tabs">
        <span :class="{ active: sortBy === 'hot' }" @click="sortBy = 'hot'">推荐</span>
        <span :class="{ active: sortBy === 'new' }" @click="sortBy = 'new'">最新</span>
      </div>
    </div>
    
    <CommentItem 
      v-for="comment in comments" 
      :key="comment.id"
      :comment="comment"
      @like="likeComment"
      @reply="replyTo"
    />
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'
import CommentItem from './CommentItem.vue'

const props = defineProps({
  postId: Number,
  post: Object
})

const comments = ref([])
const sortBy = ref('hot')

watch(sortBy, () => {
  // 重新加载评论
})
</script>
```

---

### 任务6：防止内存泄漏（2小时）

**改进 CommunityDetail.vue：**

```vue
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

// 创建 AbortController 用于取消请求
const controller = new AbortController()

const fetchPost = async () => {
  try {
    const res = await api.get(`/community/posts/${postId.value}`, {
      signal: controller.signal
    })
    post.value = res.data
  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('获取动态失败', e)
    }
  }
}

const fetchComments = async (reset = false) => {
  try {
    const res = await api.get(`/community/posts/${postId.value}/comments`, {
      params: { page: commentPage.value, page_size: 20 },
      signal: controller.signal
    })
    // 处理响应
  } catch (e) {
    if (e.name !== 'AbortError') {
      console.error('获取评论失败', e)
    }
  }
}

onMounted(() => {
  fetchPost()
  fetchComments(true)
})

onBeforeUnmount(() => {
  // 取消所有待处理的请求
  controller.abort()
})
</script>
```

---

## 第三周：代码重构

### 任务7：消除重复代码（3小时）

**创建 UserService：**

**文件：** `backend/app/services/user_service.py`

```python
from app.models.user import User, UserVIP
from app.schemas.user import UserBriefResponse
from datetime import datetime

class UserService:
    """用户服务 - 统一处理用户相关逻辑"""
    
    @staticmethod
    async def get_user_vip(db, user_id: int) -> Optional[UserVIP]:
        """获取用户VIP信息"""
        result = await db.execute(
            select(UserVIP).where(UserVIP.user_id == user_id)
        )
        return result.scalar_one_or_none()
    
    @staticmethod
    async def is_user_vip(db, user_id: int) -> bool:
        """检查用户是否是VIP"""
        vip = await UserService.get_user_vip(db, user_id)
        return vip and vip.is_active and vip.expire_date > datetime.utcnow()
    
    @staticmethod
    async def get_user_vip_level(db, user_id: int) -> int:
        """获取用户VIP等级"""
        vip = await UserService.get_user_vip(db, user_id)
        if vip and vip.is_active and vip.expire_date > datetime.utcnow():
            return vip.vip_level or 0
        return 0
    
    @staticmethod
    async def get_user_brief(db, user: User) -> UserBriefResponse:
        """获取用户简要信息"""
        is_vip = await UserService.is_user_vip(db, user.id)
        vip_level = await UserService.get_user_vip_level(db, user.id)
        
        return UserBriefResponse(
            id=user.id,
            username=user.username,
            nickname=user.nickname,
            avatar=user.avatar,
            is_vip=is_vip,
            vip_level=vip_level
        )
    
    @staticmethod
    async def batch_get_user_briefs(db, user_ids: List[int]) -> dict:
        """批量获取用户简要信息"""
        if not user_ids:
            return {}
        
        # 批量查询用户
        users_result = await db.execute(select(User).where(User.id.in_(user_ids)))
        users_map = {u.id: u for u in users_result.scalars().all()}
        
        # 批量查询VIP
        vip_result = await db.execute(
            select(UserVIP).where(UserVIP.user_id.in_(user_ids))
        )
        vip_map = {v.user_id: v for v in vip_result.scalars().all()}
        
        # 构建结果
        result = {}
        for user_id in user_ids:
            user = users_map.get(user_id)
            if not user:
                continue
            
            vip = vip_map.get(user_id)
            is_vip = vip and vip.is_active and vip.expire_date > datetime.utcnow()
            vip_level = vip.vip_level if is_vip else 0
            
            result[user_id] = UserBriefResponse(
                id=user.id,
                username=user.username,
                nickname=user.nickname,
                avatar=user.avatar,
                is_vip=is_vip,
                vip_level=vip_level
            )
        
        return result
```

**在 API 中使用：**

```python
from app.services.user_service import UserService

@router.get("/posts/{post_id}/comments")
async def get_comments(...):
    # ... 获取评论 ...
    
    # 使用 UserService 批量获取用户信息
    user_ids = list(set(c.user_id for c in comments))
    user_briefs = await UserService.batch_get_user_briefs(db, user_ids)
    
    # 构建响应
    response = []
    for comment in comments:
        user_brief = user_briefs.get(comment.user_id)
        if not user_brief:
            continue
        
        response.append({
            "id": comment.id,
            "user": user_brief,
            # ... 其他字段 ...
        })
    
    return response
```

---

## 性能测试

### 基准测试脚本

**文件：** `tests/performance_test.py`

```python
import asyncio
import time
from app.core.database import AsyncSessionLocal
from app.api.community import get_posts

async def benchmark_get_posts():
    """测试获取动态列表的性能"""
    async with AsyncSessionLocal() as db:
        start = time.time()
        
        for i in range(10):
            result = await get_posts(
                page=1,
                page_size=20,
                feed_type="recommend",
                db=db
            )
        
        elapsed = time.time() - start
        print(f"10次请求耗时: {elapsed:.2f}秒")
        print(f"平均耗时: {elapsed/10:.2f}秒")
        print(f"QPS: {10/elapsed:.2f}")

if __name__ == "__main__":
    asyncio.run(benchmark_get_posts())
```

**运行测试：**
```bash
python tests/performance_test.py
```

---

## 验收标准

### 性能指标

| 指标 | 优化前 | 优化后 | 目标 |
|-----|------|------|-----|
| 视频列表响应时间 | 2-3s | 200-300ms | ✅ |
| 评论列表响应时间 | 1-2s | 100-200ms | ✅ |
| 数据库查询数 | 40+ | 3-5 | ✅ |
| 缓存命中率 | 0% | 70%+ | ✅ |
| 前端首屏加载时间 | 3-4s | 1-2s | ✅ |

### 代码质量指标

| 指标 | 目标 |
|-----|-----|
| 单元测试覆盖率 | 70%+ |
| 代码重复率 | <5% |
| 安全漏洞数 | 0 |
| 性能警告数 | 0 |

---

## 常见问题

### Q1: 如何验证缓存是否生效？

```python
# 添加日志
import logging
logger = logging.getLogger(__name__)

@router.get("/videos")
async def list_videos(...):
    cache_key = f"videos:list:{category_id}:{page}"
    
    cached = await CacheService.get(cache_key)
    if cached:
        logger.info(f"Cache HIT: {cache_key}")
        return cached
    
    logger.info(f"Cache MISS: {cache_key}")
    # ... 查询数据库 ...
```

### Q2: 如何处理缓存失效？

```python
# 在更新数据时清除缓存
@router.post("/posts")
async def create_post(...):
    # 创建帖子
    post = Post(...)
    db.add(post)
    await db.commit()
    
    # 清除相关缓存
    await CacheService.delete("posts:list:*")
    await CacheService.delete("home:recommend:*")
```

### Q3: 如何监控性能改进？

```python
# 添加性能监控
import time

async def measure_performance(func):
    start = time.time()
    result = await func()
    elapsed = time.time() - start
    
    logger.info(f"{func.__name__} took {elapsed:.3f}s")
    return result
```

---

**预计总工作量：** 2-3周
**预期性能提升：** 10-100倍
**风险等级：** 低（所有改动都是向后兼容的）
